--[[
在string库中功能最强大的函数是：

string.find（字符串查找）
string.gsub（全局字符串替换）
string.gfind（全局字符串查找）
string.gmatch(返回查找到字符串的迭代器)

这些函数都是基于模式匹配的。与其他脚本语言不同的是，Lua并不使用POSIX规范的正则表达式[4]（也写作regexp）来进行模式匹配。主要的原因出于程序大小方面的考虑：实现一个典型的符合POSIX标准的regexp大概需要4000行代码，这比整个Lua标准库加在一起都大。权衡之下，Lua中的模式匹配的实现只用了500行代码，当然这意味着不可能实现POSIX所规范的所有更能。然而，Lua中的模式匹配功能是很强大的，并且包含了一些使用标准POSIX模式匹配不容易实现的功能。

下面的表列出了Lua支持的所有字符类：

单个字符(除^$()%.[]*+-?外): 与该字符自身配对
.(点): 与任何字符配对
%a: 与任何字母配对
%c: 与任何控制符配对(例如\n)
%d: 与任何数字配对
%l: 与任何小写字母配对
%p: 与任何标点(punctuation)配对
%s: 与空白字符配对
%u: 与任何大写字母配对
%w: 与任何字母/数字配对
%x: 与任何十六进制数配对
%z: 与任何代表0的字符配对
%x(此处x是非字母非数字字符): 与字符x配对. 主要用来处理表达式中有功能的字符(^$()%.[]*+-?)的配对问题, 例如%%与%配对
[数个字符类]: 与任何[]中包含的字符类配对. 例如[%w_]与任何字母/数字, 或下划线符号(_)配对
[^数个字符类]: 与任何不包含在[]中的字符类配对. 例如[^%s]与任何非空白字符配对

可以使用修饰符来修饰模式增强模式的表达能力，Lua中的模式修饰符有四个：

+      匹配前一字符1次或多次
*      匹配前一字符0次或多次
-      匹配前一字符0次或多次
?      匹配前一字符0次或1次

'+'，匹配一个或多个字符，总是进行最长的匹配。比如，模式串 '%a+' 匹配一个或多个字母或者一个单词：

print(string.gsub("one, and two; and three", "%a+", "word"))
    --> word, word word; word word

'%d+' 匹配一个或多个数字（整数）：

i, j = string.find("the number 1298 is even", "%d+")
print(i,j)    --> 12  15

'*' 与 '+' 类似，但是他匹配一个字符0次或多次出现.一个典型的应用是匹配空白。比如，为了匹配一对圆括号()或者括号之间的空白，可以使用 '%(%s*%)'。（ '%s*' 用来匹配0个或多个空白。由于圆括号在模式中有特殊的含义，所以我们必须使用 '%' 转义他。）再看一个例子，'[_%a][_%w]*' 匹配Lua程序中的标示符：字母或者下划线开头的字母下划线数字序列。
'-' 与 '*' 一样，都匹配一个字符的0次或多次出现，但是他进行的是最短匹配。某些时候这两个用起来没有区别，但有些时候结果将截然不同。比如，如果你使用模式 '[_%a][_%w]-' 来查找标示符，你将只能找到第一个字母，因为 '[_%w]-' 永远匹配空。另一方面，假定你想查找C程序中的注释，很多人可能使用 '/%*.*%*/'（也就是说 "/*" 后面跟着任意多个字符，然后跟着 "*/" ）。然而，由于 '.*' 进行的是最长匹配，这个模式将匹配程序中第一个 "/*" 和最后一个 "*/" 之间所有部分：

test = "int x; /* x */ int y; /* y */"
print(string.gsub(test, "/%*.*%*/", "<COMMENT>"))
    --> int x; <COMMENT>

然而模式 '.-' 进行的是最短匹配，她会匹配 "/*" 开始到第一个 "*/" 之前的部分：

test = "int x; /* x */ int y; /* y */"
print(string.gsub(test, "/%*.-%*/", "<COMMENT>"))
    --> int x; <COMMENT> int y; <COMMENT>
s
'?' 匹配一个字符0次或1次。举个例子，假定我们想在一段文本内查找一个整数，整数可能带有正负号。模式 '[+-]?%d+' 符合我们的要求，它可以匹配像 "-12"、"23" 和 "+1009" 等数字。'[+-]' 是一个匹配 '+' 或者 '-' 的字符类；接下来的 '?' 意思是匹配前面的字符类0次或者1次。
与其他系统的模式不同的是，Lua中的修饰符不能用字符类；不能将模式分组然后使用修饰符作用这个分组。比如，没有一个模式可以匹配一个可选的单词（除非这个单词只有一个字母）。下面我将看到，通常你可以使用一些高级技术绕开这个限制。
以 '^' 开头的模式只匹配目标串的开始部分，相似的，以 '$' 结尾的模式只匹配目标串的结尾部分。这不仅可以用来限制你要查找的模式，还可以定位（anchor）模式。比如：

if string.find(s, "^%d") then ...

检查字符串s是否以数字开头，而

if string.find(s, "^[+-]?%d+$") then ...

检查字符串s是否是一个整数。
'%b' 用来匹配对称的字符。常写为 '%bxy' ，x和y是任意两个不同的字符；x作为匹配的开始，y作为匹配的结束。比如，'%b()' 匹配以 '(' 开始，以 ')' 结束的字符串：

print(string.gsub("a (enclosed (in) parentheses) line", "%b()", ""))
--> a line

常用的这种模式有：'%b()' ，'%b[]'，'%b%{%}' 和 '%b<>'。你也可以使用任何字符作为分隔符。
--]]

KeyWords = {
	[1] = "你好你好啊{a0}",
	[2] = "你好{p0}/{p1}",
}

Language = Language or {}

function Language.Lan(key, ...)
	local arg = {...}
	local str = type(key) == "number" and KeyWords[key] or key
	if str == nil then
		str = tostring(key)
	end

	local function FormatText(n, m)
		print(n, m,"n = ......")
		return tostring(arg[tonumber(n) + 1])
	end
	local result = string.gsub(str, "{p(%d+)}", FormatText)
	return result
end

_L = Language.Lan

-- print(_L(1, "明明"), "111...")
-- print(_L(2, "明明", "白白"), "222...")

local s = "hello_ world from Lua"
for w in string.find(s, "%w_") do
	print(w)
end


